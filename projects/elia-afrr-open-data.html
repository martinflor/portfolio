<!--
File: projects/elia-afrr-open-data.html

Images expected (adjust filenames if yours differ):
- ../assets/img/posts/elia-afrr/vw_capacity_prices_4h.png                 (UP & DOWN in same plot; no toggle)
- ../assets/img/posts/elia-afrr/p_accept_vs_bid_up.png
- ../assets/img/posts/elia-afrr/p_accept_vs_bid_down.png
- ../assets/img/posts/elia-afrr/bid_times_p_accept_up.png
- ../assets/img/posts/elia-afrr/bid_times_p_accept_down.png

Folder suggestion:
assets/img/posts/elia-afrr/

Math:
- Inline: \( ... \)
- Block:  \[ ... \]
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ELIA Open Data - aFRR Capacity</title>

  <!-- Your existing site styles -->
  <link rel="stylesheet" href="../assets/css/style.css" />
  <script src="../assets/js/theme.js"></script>
  <script defer src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>


  <!-- Post-specific styling (minimal, uses your theme variables) -->
  <style>
    .post-header { margin-top: 22px; }
    .post-meta { opacity: 0.78; font-size: 14px; margin-top: 6px; }
    .toc { margin-top: 14px; }
    .toc a { border-bottom: 1px dashed rgba(185,2,9,0.55); }
    .toc a:hover { border-bottom-style: solid; text-decoration: none; }

    .post { margin-top: 18px; padding: 18px; }
    .post h2 { margin-top: 18px; }
    .post h3 { margin-top: 14px; font-size: 17px; }

    .note {
      border: 1px solid rgba(185,2,9,0.28);
      background: linear-gradient(180deg, rgba(185,2,9,0.10), rgba(185,2,9,0.03));
      border-radius: 12px;
      padding: 12px;
      margin: 14px 0;
    }
    .note .label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 6px;
    }
    .note p { margin: 0; opacity: 0.92; }

    figure {
      margin: 16px 0;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--card-border);
      background: rgba(255,255,255,0.03);
    }
    figure img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 10px;
      border: 1px solid var(--card-border);
    }
    figcaption {
      margin-top: 10px;
      font-size: 13px;
      opacity: 0.78;
      line-height: 1.5;
    }

    code.inline {
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--card-border);
      background: rgba(255,255,255,0.04);
      font-size: 0.95em;
    }

    .pillrow {
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top: 10px;
    }
    .pill {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:9px 10px;
      border-radius:999px;
      border:1px solid var(--card-border);
      background: rgba(255,255,255,0.04);
      font-size: 13px;
      line-height: 1;
    }
    .pill::before{
      content:"";
      width:8px;
      height:8px;
      border-radius:3px;
      background: var(--accent);
      display:inline-block;
      opacity:0.95;
    }

    .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      margin-top: 14px;
    }
    @media (max-width: 860px){
      .two-col { grid-template-columns: 1fr; }
    }

    /* === UP/DOWN per-figure toggle === */
    .fig-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .seg{
      display:inline-flex;
      border:1px solid var(--card-border);
      border-radius:999px;
      overflow:hidden;
      background: rgba(255,255,255,0.03);
    }
    .seg button{
      appearance:none;
      border:0;
      background:transparent;
      color: var(--text);
      padding:8px 10px;
      font-size:12px;
      cursor:pointer;
    }
    .seg button + button{
      border-left:1px solid var(--card-border);
    }
    .seg button.active{
      background: rgba(185,2,9,0.14);
      font-weight:700;
    }
    .seg button:hover{
      background: rgba(185,2,9,0.10);
    }
  </style>

  <!-- MathJax (easy LaTeX editing) -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)'], ['$', '$']],
        displayMath: [['\\[','\\]'], ['$$','$$']]
      },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>
  <div class="container">
    <!-- Navbar -->
    <header class="nav">
      <div class="brand">
        <span class="dot"></span>
        <span>Florian Martin</span>
      </div>

      <nav class="navlinks">
        <a href="../index.html">About</a>
        <a href="../projects.html" class="active">Projects / Blog</a>
      </nav>

      <div class="actions">
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle night mode" title="Toggle night mode">
          <span class="icon" aria-hidden="true"></span>
        </button>
      </div>
    </header>

    <!-- Post header -->
    <section class="post-header">
      <div class="kicker">Project / Blog</div>
      <h1>ELIA Open Data - aFRR Capacity (Bidding Insights)</h1>
      <div class="post-meta">
        Datasets: aFRR capacity prices/awarded volumes <code class="inline">ods125</code>.
      </div>

      <div class="pillrow">
        <span class="pill">Energy Markets</span>
        <span class="pill">aFRR</span>
        <span class="pill">Pay-as-bid</span>
        <span class="pill">Decision Support</span>
      </div>

      <div class="toc card">
        <div class="kicker">Contents</div>
        <p style="margin:10px 0 0;">
          <a href="#context">Context</a> ¬∑
          <a href="#data">Data sources</a> ¬∑
          <a href="#payasbid">Pay-as-bid reminder</a> ¬∑
          <a href="#vw">Volume-weighted capacity prices</a> ¬∑
          <a href="#paccept">Acceptance probability vs bid</a> ¬∑
          <a href="#ev">Recommended bid via expected value</a> ¬∑
          <a href="#limits">Limitations</a>
        </p>
      </div>
    </section>

    <!-- Post body -->
    <article class="card post">
      <h2 id="context">Context</h2>
      <p>
        This post explores <span class="emph">automatic Frequency Restoration Reserve (aFRR)</span>
        capacity bidding using ELIA Open Data. The objective is not price forecasting,
        but <span class="emph">decision support</span>: understanding how historical clearing behavior
        translates into acceptance probabilities and how those probabilities can inform
        rational bid selection in a <span class="emph">pay-as-bid</span> market.
      </p>
      
      <p>
        Instead of asking ‚Äúwhat was the price?‚Äù, we focus on a more practical question:
        <span class="emph">‚ÄúAt a given bid price, how likely was acceptance?‚Äù</span>
        This shift turns historical data into a tool for risk-aware bidding.
      </p>

      <p>
        Acceptance probabilities turn bid prices into <span class="emph">risk-adjusted decisions</span>, allowing optimizers to trade price against participation instead of blindly maximizing nominal price.
      </p>


      <h2 id="data">Data sources</h2>
      <div class="two-col">
        <div class="item">
          <h3>aFRR capacity prices & awarded volumes</h3>
          <p>Capacity market results come from:</p>
          <ul style="margin: 0; padding-left: 18px; line-height: 1.65;">
            <li><code class="inline">ods125</code> - awarded capacity prices & awarded volumes</li>
          </ul>
        </div>
      </div>

      <div class="note" id="payasbid">
        <div class="label">Market rule that matters</div>
        <p>
          aFRR <span class="emph">capacity</span> prices are <span class="emph">pay-as-bid</span> (not pay-as-cleared).
          Each accepted bid is paid at its own bid price - which makes acceptance probability and bid selection central to strategy design.
        </p>

        <p style="margin-top:10px;">
          In pay-as-bid markets, bidding too low guarantees acceptance but caps revenue,
          while bidding too high maximizes price but risks non-selection.
          The optimal bid therefore balances <span class="emph">price level</span>
          and <span class="emph">probability of acceptance.</span>
        </p>
      </div>




      <h2 id="vw">Volume-weighted capacity prices</h2>
      <p>
        Capacity prices can be noisy if awarded volumes vary. A robust way to summarize ‚Äúwhat the system actually paid‚Äù
        is the <span class="emph">volume-weighted capacity price</span>:
      </p>

      <p style="margin-top: 8px;">
        \[
          P_{\text{vw}} = \frac{\sum_i P_i \cdot V_i}{\sum_i V_i}
        \]
      </p>

      <p>
        where \(P_i\) is the awarded capacity price and \(V_i\) the awarded volume (within the same time bucket and direction).
        In this figure, UP and DOWN are shown together (so no toggle is needed).
      </p>

      <figure>
        <div id="vwChart" style="width:100%;height:420px;"></div>
        <figcaption>
          <span class="emph">Figure 1.</span> Volume-weighted aFRR capacity prices (4h step) with both UP & DOWN.
        </figcaption>
      </figure>


      <p style="margin-top:10px;">
        Two insights stand out. First, UP capacity prices are structurally higher and more volatile,
        reflecting scarcity risk and asymmetric system needs. Second, prices cluster for long periods
        before spiking sharply, suggesting that extreme events matter, but are relatively rare.
      </p>
      
      <p>
        This asymmetry explains why acceptance curves and optimal bids differ materially
        between UP and DOWN directions later in the analysis.
      </p>


      <h2 id="paccept">Probability of being accepted vs bidding price</h2>
      <p>
        With pay-as-bid, the key question becomes:
        <span class="emph">‚ÄúIf I bid at price \(p\), what is my probability of acceptance?‚Äù</span>
      </p>
      <p>
        We estimate:
        \[
          \mathbb{P}(\text{accept} \mid p)
        \]
        and segment by time blocks (e.g. 00‚Äì04, 04‚Äì08, ‚Ä¶). Toggle below to compare UP vs DOWN acceptance behavior.
      </p>

      <p>
        Acceptance probabilities are estimated empirically from historical clearing prices.
        For each time block and direction, clearing prices are treated as an empirical distribution.
        A bid at price \(p\) is assumed accepted whenever the historical clearing price exceeds \(p\),
        yielding:
      </p>
      
      <p>
        \[
          \mathbb{P}(\text{accept}\mid p) = 1 - \text{ECDF}(p)
        \]
      </p>

       <figure class="toggle-figure" data-mode="up" data-kind="paccept">
        <div class="fig-head">
          <div class="kicker" style="margin:0;">Acceptance curves</div>
          <div class="seg" role="tablist" aria-label="Toggle UP/DOWN P(accept)">
            <button type="button" class="active" data-set="up" role="tab" aria-selected="true">UP</button>
            <button type="button" data-set="down" role="tab" aria-selected="false">DOWN</button>
          </div>
        </div>
      
        <!-- ‚úÖ Plotly container (required) -->
        <div id="pAcceptChart" style="width:100%;height:420px;"></div>
      
        <figcaption>
          <span class="emph">Figure 2.</span> Estimated \( \mathbb{P}(\text{accept}\mid p) \) vs bid price,
          segmented by 4h blocks.
        </figcaption>
      </figure>


      <p style="margin-top:10px;">
        Acceptance curves are highly non-linear. For most blocks, a small increase in bid price
        around the median can cause a disproportionate drop in acceptance probability.
        Evening blocks (16‚Äì20, 20‚Äì00) consistently tolerate higher prices, while night and morning
        blocks are more price-sensitive.
      </p>


      <h2 id="ev">Recommended bid using historical expected value</h2>
      <p>
        Acceptance probability alone isn‚Äôt enough: a very low bid might be accepted almost always, but yields little value.
        A simple historical decision rule is to maximize a proxy for expected value:
      </p>

      <p>
        \[
          \mathbb{E}(p) = p \cdot \mathbb{P}(\text{accept} \mid p)
        \]
      </p>

      <p>
        The baseline ‚Äúrecommended bid‚Äù per time block (and per direction) is the \(p\) that maximizes \(\mathbb{E}(p)\),
        then adjusted based on risk appetite (prefer acceptance vs prefer price).
      </p>

      <p>
        While this is not a full profit model (activation, penalties, and portfolio effects are ignored),
        \(p \cdot \mathbb{P}(\text{accept}\mid p)\) is a useful first-order proxy.
        It highlights price levels where marginal price increases no longer compensate
        for the loss in acceptance probability.
      </p>

      <figure class="toggle-figure" data-mode="up" data-kind="evproxy">
        <div class="fig-head">
          <div class="kicker" style="margin:0;">Bid √ó P(accept)</div>
          <div class="seg" role="tablist" aria-label="Toggle UP/DOWN expected value proxy">
            <button type="button" class="active" data-set="up" role="tab" aria-selected="true">UP</button>
            <button type="button" data-set="down" role="tab" aria-selected="false">DOWN</button>
          </div>
        </div>
      
        <!-- ‚úÖ Plotly container (required) -->
        <div id="evChart" style="width:100%;height:420px;"></div>
      
        <figcaption>
          <span class="emph">Figure 3.</span> \(\mathbb{E}(p)=p\cdot \mathbb{P}(\text{accept}\mid p)\) by time block.
          The peak suggests a historical ‚Äúsweet spot‚Äù.
        </figcaption>
      </figure>



      <p style="margin-top:10px;">
        The peak of each curve represents a historical ‚Äúsweet spot‚Äù:
        high enough to capture value, but not so high that acceptance collapses.
        These peaks differ substantially by time block and by direction,
        reinforcing that a single flat bid across the day is rarely optimal.
      </p>

      <h2 id="limits">Limitations</h2>
      <p>
        This analysis is intentionally simple and historical. Acceptance probabilities assume
        stationarity and do not condition on system state, imbalance forecasts, or competitor behavior.
        Results should therefore be interpreted as <span class="emph">baseline guidance</span>,
        not as guaranteed outcomes.
      </p>
      
      <p>
        In practice, traders may shift bids relative to these curves depending on risk appetite,
        portfolio exposure, and expected scarcity conditions.
      </p>


      <div class="note" style="margin-top:18px;">
        <div class="label">Try it yourself</div>
        <p>
          To make this analysis interactive, I built a small
          <span class="emph">Streamlit application</span> where you can:
        </p>
      
        <ul style="margin: 8px 0 10px; padding-left:18px; line-height:1.7;">
          <li>Explore aFRR capacity prices by time block</li>
          <li>Visualize acceptance probabilities vs bid price (UP & DOWN)</li>
          <li>See how the recommended bid changes with historical data</li>
        </ul>
      
        <p style="margin:0;">
          üëâ <a href="https://elia-open-data.streamlit.app/" target="_blank" rel="noreferrer">
            Open the interactive aFRR bidding app
          </a>
        </p>
      </div>


      <div class="btnrow" style="margin-top: 16px;">
        <a class="btn primary" href="../projects.html">‚Üê Back to Projects</a>
      </div>
    </article>

    <div class="footer">
      ¬© <span id="year"></span> Florian Martin ¬∑ aFRR notes built from ELIA Open Data
    </div>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
  </script>

  <!-- Toggle logic for UP/DOWN figures -->
  <script>
    (function () {
      // === Paths to CSV files (adjust if you rename files) ===
      const DATA_BASE = "../assets/data/posts/elia-afrr/";
    
      const PATHS = {
        vw: DATA_BASE + "volume_weighted_aFRR_capacity_prices_2025.csv",
    
        paccept: {
          up:   DATA_BASE + "p_accept_vs_bid_price_Up_All blocks_2025-01-01_2025-12-31.csv",
          down: DATA_BASE + "p_accept_vs_bid_price_Down_All blocks_2025-01-01_2025-12-31.csv",
        },
    
        evproxy: {
          up:   DATA_BASE + "bid_x_p_accept_vs_bid_price_Up_All blocks_2025-01-01_2025-12-31.csv",
          down: DATA_BASE + "bid_x_p_accept_vs_bid_price_Down_All blocks_2025-01-01_2025-12-31.csv",
        }
      };
    
      // Cache loaded datasets
      const cache = new Map();
    
      function cssVar(name, fallback) {
        const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        return v || fallback;
      }
    
      function plotlyTheme() {
        // Use your CSS variables if present
        const text = cssVar("--text", "#eaeaea");
        const grid = cssVar("--card-border", "rgba(255,255,255,0.12)");
        const paper = "rgba(0,0,0,0)";
        const plotbg = "rgba(0,0,0,0)";
    
        return {
          font: { color: text },
          paper_bgcolor: paper,
          plot_bgcolor: plotbg,
          xaxis: { gridcolor: grid, zerolinecolor: grid },
          yaxis: { gridcolor: grid, zerolinecolor: grid },
          legend: { orientation: "v" }
        };
      }
    
      async function loadCsv(path) {
        if (cache.has(path)) return cache.get(path);
        const data = await d3.csv(path, d3.autoType);
        cache.set(path, data);
        return data;
      }
    
      function groupByBlock(rows) {
        const by = new Map();
        rows.forEach(r => {
          const b = r.block;
          if (!by.has(b)) by.set(b, []);
          by.get(b).push(r);
        });
        // Ensure consistent sort by bid price
        for (const [k, arr] of by.entries()) {
          arr.sort((a,b) => a.bid_price_eur_mwh - b.bid_price_eur_mwh);
        }
        return by;
      }
    
      function makeTracesBlockLines(rows, yKey) {
        const by = groupByBlock(rows);
        const blocks = Array.from(by.keys()).sort(); // "00-04", "04-08", ...
        return blocks.map(block => {
          const arr = by.get(block);
          return {
            type: "scatter",
            mode: "lines",
            name: block,
            x: arr.map(d => d.bid_price_eur_mwh),
            y: arr.map(d => d[yKey]),
            line: { shape: "hv" } // matches your step-like curves
          };
        });
      }
    
      async function renderVW() {
        const rows = await loadCsv(PATHS.vw);
    
        const x = rows.map(d => new Date(d.period_start));
        const up = rows.map(d => d.vw_price_up);
        const down = rows.map(d => d.vw_price_down);
    
        const traces = [
          { type: "scatter", mode: "lines", name: "Volume-weighted UP", x, y: up },
          { type: "scatter", mode: "lines", name: "Volume-weighted DOWN", x, y: down }
        ];
    
        const base = plotlyTheme();
        const layout = {
          ...base,
          margin: { l: 55, r: 20, t: 10, b: 45 },
          xaxis: {
            ...base.xaxis,
            title: { text: "Bid price (‚Ç¨/MW¬∑h)" }
          },
          yaxis: { ...base.yaxis, title: { text: "EUR/MW/h (volume-weighted)" } },
          hovermode: "x unified"
        };
    
        Plotly.newPlot("vwChart", traces, layout, { responsive: true, displaylogo: false });
      }
    
      async function renderPAccept(mode) {
        const path = PATHS.paccept[mode];
        const rows = await loadCsv(path);
    
        const traces = makeTracesBlockLines(rows, "P_accept");
    
        const base = plotlyTheme();
        const layout = {
          ...base,
          margin: { l: 55, r: 20, t: 10, b: 50 },
          xaxis: {
            ...base.xaxis,
            title: { text: "Bid price (‚Ç¨/MW¬∑h)" },
            range: [0, 150]
          },
          yaxis: { ...base.yaxis, title: { text: "P(accept)" }, range: [0, 1.02] },
          hovermode: "closest"
        };
    
        Plotly.react("pAcceptChart", traces, layout, { responsive: true, displaylogo: false });
      }
    
      async function renderEV(mode) {
        const path = PATHS.evproxy[mode];
        const rows = await loadCsv(path);
    
        const traces = makeTracesBlockLines(rows, "bid_x_P_accept_eur_mwh");
    
        const base = plotlyTheme();
        const layout = {
          ...base,
          margin: { l: 55, r: 20, t: 10, b: 50 },
          xaxis: { ...base.xaxis, title: { text: "Bid price (‚Ç¨/MW¬∑h)" } },
          yaxis: { ...base.yaxis, title: { text: "Bid √ó P(accept) (‚Ç¨/MW¬∑h)" } },
          hovermode: "closest"
        };
    
        Plotly.react("evChart", traces, layout, { responsive: true, displaylogo: false });
      }
    
      function setToggleState(fig, mode) {
        fig.setAttribute("data-mode", mode);
        const btnUp = fig.querySelector('button[data-set="up"]');
        const btnDown = fig.querySelector('button[data-set="down"]');
        if (btnUp && btnDown) {
          const isDown = mode === "down";
          btnUp.classList.toggle("active", !isDown);
          btnDown.classList.toggle("active", isDown);
          btnUp.setAttribute("aria-selected", String(!isDown));
          btnDown.setAttribute("aria-selected", String(isDown));
        }
      }
    
      async function renderAll() {
        await renderVW();
    
        // Initialize both toggles from their data-mode
        document.querySelectorAll(".toggle-figure").forEach(async (fig) => {
          const mode = fig.getAttribute("data-mode") || "up";
          const kind = fig.getAttribute("data-kind");
          setToggleState(fig, mode);
    
          if (kind === "paccept") await renderPAccept(mode);
          if (kind === "evproxy") await renderEV(mode);
    
          fig.querySelectorAll("button[data-set]").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const next = btn.getAttribute("data-set");
              setToggleState(fig, next);
              if (kind === "paccept") await renderPAccept(next);
              if (kind === "evproxy") await renderEV(next);
            });
          });
        });
      }
    
      // Re-render on theme toggle (best-effort)
      function hookThemeButton() {
        const t = document.querySelector(".theme-toggle");
        if (!t) return;
        t.addEventListener("click", () => {
          // Theme changes might be async; re-render after a short tick
          setTimeout(() => {
            renderVW();
            renderPAccept(document.querySelector('figure[data-kind="paccept"]')?.getAttribute("data-mode") || "up");
            renderEV(document.querySelector('figure[data-kind="evproxy"]')?.getAttribute("data-mode") || "up");
          }, 50);
        });
      }
    
      // Start once Plotly + d3 are available
      window.addEventListener("DOMContentLoaded", () => {
        hookThemeButton();
        renderAll();
      });
    })();
    </script>

</body>
</html>
